<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Pixel Brawl - 2D Fighting Game</title>
  <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      background: linear-gradient(180deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
      font-family: 'Press Start 2P', cursive;
      color: #eee;
      overflow: hidden;
    }
    h1 {
      font-size: 1.2rem;
      margin-bottom: 10px;
      text-shadow: 0 0 10px #e94560;
      color: #e94560;
    }
    #gameContainer {
      position: relative;
      border: 4px solid #e94560;
      border-radius: 8px;
      box-shadow: 
        0 0 20px rgba(233, 69, 96, 0.5),
        inset 0 0 60px rgba(0,0,0,0.3);
      /* switched to smooth rendering for high-res display */
    }
    canvas {
      display: block;
      background: #0f3460;
      width: 960px;
      height: 540px;
      image-rendering: pixelated;
      image-rendering: crisp-edges;
    }
    #controls {
      margin-top: 15px;
      font-size: 0.5rem;
      text-align: center;
      line-height: 2;
      max-width: 960px;
      color: #aaa;
    }
    .player-control { color: #4ade80; }
    .player2-control { color: #60a5fa; }
    #startScreen, #gameOverScreen {
      position: absolute;
      top: 0; left: 0; right: 0; bottom: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      background: rgba(0,0,0,0.85);
      z-index: 10;
    }
    #gameOverScreen { display: none; }
    #startScreen h2, #gameOverScreen h2 {
      font-size: 1rem;
      margin-bottom: 20px;
      color: #e94560;
    }
    .btn {
      font-family: 'Press Start 2P', cursive;
      font-size: 0.6rem;
      padding: 15px 25px;
      margin: 8px;
      border: 3px solid #e94560;
      background: transparent;
      color: #e94560;
      cursor: pointer;
      transition: all 0.2s;
    }
    .btn:hover {
      background: #e94560;
      color: #1a1a2e;
      box-shadow: 0 0 20px #e94560;
    }
    #menuBtn {
      position: absolute;
      bottom: 12px;
      right: 12px;
      font-size: 0.5rem;
      padding: 10px 16px;
      z-index: 5;
    }
    #roundScreen, #pauseMenu {
      position: absolute;
      top: 0; left: 0; right: 0; bottom: 0;
      display: none;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      background: rgba(0,0,0,0.9);
      z-index: 15;
    }
    #pauseMenu h2 { font-size: 0.8rem; margin-bottom: 20px; }
    /* Color selection modal (dropdown) */
    #colorSelect {
      position: absolute;
      top: 0; left: 0; right: 0; bottom: 0;
      display: none;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      background: rgba(0,0,0,0.92);
      z-index: 20;
    }
    #colorSelect h2 { color: #e94560; margin-bottom: 14px; }
    #colorDropdown { font-family: 'Press Start 2P', cursive; font-size: 0.6rem; padding: 12px; background:#111; color:#fff; border:3px solid #e94560; }
    .colorActions { margin-top: 14px; }
  </style>
</head>
<body>
  <h1>⚔️ PIXEL BRAWL ⚔️</h1>
  <div id="gameContainer">
    <canvas id="gameCanvas" width="960" height="540"></canvas>
    <div id="startScreen">
      <h2>PIXEL BRAWL</h2>
      <button class="btn" id="vsAiBtn">1 PLAYER (VS AI)</button>
      <button class="btn" id="vsPlayerBtn">2 PLAYERS</button>
      <p style="font-size:0.4rem;margin-top:25px;color:#888;">game made by aks</p>
    </div>
    <div id="gameOverScreen">
      <h2 id="winnerText">PLAYER 1 WINS!</h2>
      <p id="roundScoreText" style="font-size:0.5rem;margin:10px 0;color:#aaa;"></p>
      <button class="btn" id="playAgainBtn">PLAY AGAIN</button>
      <button class="btn" id="menuBtnOver">MENU</button>
    </div>
    <div id="roundScreen">
      <h2 id="roundTitle">ROUND 1</h2>
      <p id="roundSubtitle" style="font-size:0.5rem;margin:15px 0;color:#aaa;"></p>
    </div>
    <div id="pauseMenu">
      <h2>PAUSED</h2>
      <button class="btn" id="resumeBtn">RESUME</button>
      <button class="btn" id="quitToMenuBtn">QUIT TO MENU</button>
    </div>
    <button class="btn" id="menuBtn" style="display:none;">MENU</button>

    <!-- Color selection modal for player setup (single or 2-player) -->
    <div id="colorSelect">
      <h2>Choose Player Colors</h2>
      <div style="display:flex;gap:20px;align-items:center;">
        <div style="text-align:center;">
          <div style="font-size:0.6rem;margin-bottom:8px;color:#aaa;">Player 1</div>
          <select id="colorDropdown">
            <option value="#e94560">Red</option>
            <option value="#4ade80">Green</option>
            <option value="#60a5fa">Blue</option>
            <option value="#7c3aed">Purple</option>
            <option value="#f59e0b">Orange</option>
            <option value="#10b981">Teal</option>
          </select>
        </div>
        <div style="text-align:center;">
          <div style="font-size:0.6rem;margin-bottom:8px;color:#aaa;">Player 2</div>
          <select id="colorDropdownP2">
            <option value="#7c3aed">Purple</option>
            <option value="#4ade80">Green</option>
            <option value="#60a5fa">Blue</option>
            <option value="#e94560">Red</option>
            <option value="#f59e0b">Orange</option>
            <option value="#10b981">Teal</option>
          </select>
        </div>
      </div>
      <div class="colorActions">
        <button class="btn" id="colorStartBtn">START</button>
        <button class="btn" id="colorCancelBtn">CANCEL</button>
      </div>
    </div>
  </div>
  <div id="controls">
    <span class="player-control">P1: A/D move • W jump • G punch • H kick</span><br>
    <span class="player2-control">P2: ←/→ move • ↑ jump • K punch • L kick</span>
  </div>

  <script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    ctx.imageSmoothingEnabled = false;
    const startScreen = document.getElementById('startScreen');
    const gameOverScreen = document.getElementById('gameOverScreen');
    const winnerText = document.getElementById('winnerText');

    // Color selection elements
    window.playerColor = '#e94560';
    window.player2Color = '#7c3aed';
    window.pendingMode = null; // 'single' or 'duo'
    const colorSelect = document.getElementById('colorSelect');
    const colorDropdown = document.getElementById('colorDropdown');
    const colorDropdownP2 = document.getElementById('colorDropdownP2');
    const colorStartBtn = document.getElementById('colorStartBtn');
    const colorCancelBtn = document.getElementById('colorCancelBtn');

    colorStartBtn.addEventListener('click', () => {
      const chosen1 = colorDropdown.value;
      const chosen2 = colorDropdownP2.value;
      window.playerColor = chosen1 || window.playerColor;
      window.player2Color = chosen2 || window.player2Color;
      colorSelect.style.display = 'none';
      document.getElementById('menuBtn').style.display = 'block';
      // Start game according to pendingMode
      if (window.pendingMode === 'single') {
        // Single-player: P1 uses arrow keys (movement), A punch, D kick
        document.getElementById('controls').innerHTML = '<span class="player-control">P1: ←/→ move • ↑ jump • A punch • D kick</span>';
        startScreen.style.display = 'none';
        initGame(true);
        gameRunning = true;
      } else {
        // Two-player: P1 WASD, P2 arrow keys (K/L punch/kick)
        document.getElementById('controls').innerHTML = '<span class="player-control">P1: A/D move • W jump • G punch • H kick</span><br><span class="player2-control">P2: ←/→ move • ↑ jump • K punch • L kick</span>';
        startScreen.style.display = 'none';
        initGame(false);
        gameRunning = true;
      }
      window.pendingMode = null;
    });

    colorCancelBtn.addEventListener('click', () => {
      colorSelect.style.display = 'none';
      startScreen.style.display = 'flex';
      window.pendingMode = null;
    });

    // Game constants
    const GRAVITY = 0.6;
    const GROUND_Y = 450;
    const PIXEL_SIZE = 4;
    const ROUND_TIME = 60; // seconds per round
    const TOTAL_ROUNDS = 5;
    // Visual effects (blood particles etc.)
    const effects = [];

    // Platforms (x, y, width, height)
    const platforms = [
      { x: 80, y: 380, w: 150, h: 16 },   // left low
      { x: 280, y: 320, w: 180, h: 16 },  // left-center high
      { x: 500, y: 280, w: 200, h: 16 },  // center highest
      { x: 720, y: 340, w: 170, h: 16 },  // right-center mid
      { x: 850, y: 380, w: 100, h: 16 },  // right low
      { x: 150, y: 240, w: 120, h: 16 },  // left upper
      { x: 400, y: 200, w: 140, h: 16 },  // center upper
      { x: 650, y: 220, w: 160, h: 16 },  // right upper
      { x: 300, y: 420, w: 100, h: 16 },  // mid low
      { x: 750, y: 400, w: 120, h: 16 }   // right mid-low
    ];

    // Powerups array
    const powerups = [];
    let powerupSpawnTimer = 0;
    const POWERUP_SPAWN_INTERVAL = 600; // 10 seconds at 60fps
    const POWERUP_TYPES = ['strength', 'speed', 'jump', 'opacity', 'teleport', 'swap'];

    function spawnPowerup() {
      const type = POWERUP_TYPES[Math.floor(Math.random() * POWERUP_TYPES.length)];
      const platforms_and_ground = [...platforms, { x: 0, y: GROUND_Y, w: canvas.width, h: 50 }];
      const spawnOn = platforms_and_ground[Math.floor(Math.random() * platforms_and_ground.length)];
      const px = spawnOn.x + Math.random() * (spawnOn.w - 20);
      const py = spawnOn.y - 25;
      powerups.push({ x: px, y: py, type: type, life: 600, rotation: 0 });
    }

    function updatePowerups() {
      powerupSpawnTimer++;
      if (powerupSpawnTimer >= POWERUP_SPAWN_INTERVAL) {
        spawnPowerup();
        powerupSpawnTimer = 0;
      }
      for (let i = powerups.length - 1; i >= 0; i--) {
        const pu = powerups[i];
        pu.life--;
        pu.rotation += 0.05;
        if (pu.life <= 0) powerups.splice(i, 1);
      }
    }

    function drawPowerups() {
      for (const pu of powerups) {
        ctx.save();
        ctx.translate(pu.x + 10, pu.y + 10);
        ctx.rotate(pu.rotation);
        
        const colors = { strength: '#ff4444', speed: '#44ff44', jump: '#4444ff', opacity: '#ffff44', teleport: '#ff44ff', swap: '#44ffff' };
        ctx.fillStyle = colors[pu.type];
        ctx.fillRect(-10, -10, 20, 20);
        ctx.strokeStyle = '#fff';
        ctx.lineWidth = 2;
        ctx.strokeRect(-10, -10, 20, 20);
        
        // Draw icon for each powerup type
        ctx.fillStyle = '#1a1a2e';
        if (pu.type === 'strength') {
          // Fist icon
          ctx.fillRect(-4, -6, 3, 8);
          ctx.fillRect(1, -6, 3, 8);
          ctx.fillRect(-6, -2, 12, 3);
        } else if (pu.type === 'speed') {
          // Lightning bolt
          ctx.fillRect(-2, -6, 2, 4);
          ctx.fillRect(0, -4, 4, 2);
          ctx.fillRect(2, -2, 2, 4);
          ctx.fillRect(-2, 2, 4, 2);
        } else if (pu.type === 'jump') {
          // Up arrow
          ctx.fillRect(-1, -7, 2, 8);
          ctx.fillRect(-4, -3, 3, 2);
          ctx.fillRect(1, -3, 3, 2);
        } else if (pu.type === 'opacity') {
          // Ghost/fade
          ctx.fillRect(-5, -5, 2, 8);
          ctx.fillRect(3, -5, 2, 8);
          ctx.fillRect(-5, -5, 10, 3);
          ctx.fillRect(-3, 2, 2, 2);
          ctx.fillRect(1, 2, 2, 2);
        } else if (pu.type === 'teleport') {
          // Portal
          ctx.beginPath();
          ctx.arc(-3, 0, 4, 0, Math.PI * 2);
          ctx.stroke();
          ctx.beginPath();
          ctx.arc(3, 0, 4, 0, Math.PI * 2);
          ctx.stroke();
        } else if (pu.type === 'swap') {
          // Swap arrows
          ctx.fillRect(-6, -1, 4, 2);
          ctx.fillRect(-5, -2, 2, 1);
          ctx.fillRect(-5, 1, 2, 1);
          ctx.fillRect(2, -1, 4, 2);
          ctx.fillRect(5, -2, 2, 1);
          ctx.fillRect(5, 1, 2, 1);
        }
        
        ctx.restore();
      }
    }

    function drawPlatforms() {
      ctx.fillStyle = '#5a6c7d';
      for (const plat of platforms) {
        ctx.fillRect(plat.x, plat.y, plat.w, plat.h);
        ctx.strokeStyle = '#8fa3b5';
        ctx.lineWidth = 2;
        ctx.strokeRect(plat.x, plat.y, plat.w, plat.h);
      }
    }

    function checkPowerupCollision(fighter) {
      for (let i = powerups.length - 1; i >= 0; i--) {
        const pu = powerups[i];
        if (fighter.x < pu.x + 20 && fighter.x + fighter.width > pu.x && 
            fighter.y < pu.y + 20 && fighter.y + fighter.height > pu.y) {
          applyPowerup(fighter, pu.type);
          powerups.splice(i, 1);
        }
      }
    }

    function applyPowerup(fighter, type) {
      if (type === 'strength') {
        fighter.strengthBoost = 600;
      } else if (type === 'speed') {
        fighter.speedBoost = 600;
      } else if (type === 'jump') {
        fighter.jumpBoost = 600;
      } else if (type === 'opacity') {
        fighter.opacityBoost = 600;
      } else if (type === 'teleport') {
        fighter.x = fighter.x > canvas.width / 2 ? 100 : canvas.width - 160;
      } else if (type === 'swap') {
        const other = fighter === p1 ? p2 : p1;
        const tempX = fighter.x;
        fighter.x = other.x;
        other.x = tempX;
      }
    }

    function spawnBlood(x, y, color) {
      for (let i = 0; i < 8; i++) {
        const angle = Math.random() * Math.PI * 2;
        const speed = 1 + Math.random() * 2.5;
        effects.push({ x: x, y: y, vx: Math.cos(angle) * speed, vy: Math.sin(angle) * speed - 1.5, life: 30 + Math.random() * 20, size: 1 + Math.random() * 2, col: color });
      }
    }

    function updateEffects() {
      for (let i = effects.length - 1; i >= 0; i--) {
        const e = effects[i];
        e.vy += 0.12; // gravity on particles
        e.x += e.vx; e.y += e.vy;
        e.life -= 1;
        if (e.life <= 0) effects.splice(i, 1);
      }
    }

    function drawEffects() {
      for (const e of effects) {
        ctx.fillStyle = e.col;
        ctx.fillRect(e.x, e.y, e.size, e.size);
      }
    }

    // Fighter class - proper pixel art character
    class Fighter {
      constructor(x, color, keys, facing, isAI = false) {
        this.x = x;
        this.y = GROUND_Y;
        this.width = 60;
        this.height = 84;
        this.vx = 0;
        this.vy = 0;
        this.health = 100;
        this.color = color;
        this.accColor = color; // accent (belt, etc)
        this.facing = facing;
        this.keys = keys;
        this.isAI = isAI;
        this.isAttacking = false;
        this.attackType = null;
        this.attackTimer = 0;
        this.attackCooldown = 0;
        this.attackHit = false;
        this.aiTimer = 0;
        this.animFrame = 0;
        this.hitTimer = 0;
        this.lastHitX = 0;
        this.lastHitY = 0;
      this.strengthBoost = 0;
      this.speedBoost = 0;
      this.jumpBoost = 0;
      this.opacityBoost = 0;
      this.onPlatform = false;
      }

      get hitboxRect() {
        const punchW = 24;
        const kickW = 28;
        const w = this.attackType === 'punch' ? punchW : kickW;
        return {
          x: this.facing === 1 ? this.x + this.width : this.x - w,
          y: this.attackType === 'kick' ? this.y + this.height - 20 : this.y + 20,
          w: w,
          h: this.attackType === 'kick' ? 16 : 14
        };
      }

      aiUpdate(opponent) {
        this.aiTimer--;
        if (this.aiTimer > 0) return;
        this.aiTimer = 15 + Math.random() * 20;

        const dist = Math.abs((opponent.x + opponent.width/2) - (this.x + this.width/2));
        const inRange = dist < 80;
        const closeRange = dist < 50;

        this.facing = opponent.x + opponent.width/2 < this.x + this.width/2 ? -1 : 1;

        if (inRange && !this.isAttacking && this.attackCooldown <= 0) {
          if (Math.random() < 0.5) this.attack(closeRange ? 'kick' : 'punch');
        } else if (closeRange && opponent.y < GROUND_Y - 5) {
          this.attack('punch');
        } else if (!inRange) {
          this.vx = this.facing * 3;
        }
        
        // AI jump logic
        if (Math.random() < 0.15 && this.onPlatform) {
          const jumpPower = this.jumpBoost > 0 ? -28 : -16;
          this.vy = jumpPower;
        }
      }

      update(opponent) {
        if (this.isAI) this.aiUpdate(opponent);

        if (this.attackCooldown > 0) this.attackCooldown--;
        if (this.isAttacking) {
          this.attackTimer--;
          if (this.attackTimer <= 0) {
            this.isAttacking = false;
            this.attackCooldown = 25;
          }
          const hitbox = this.hitboxRect;
          if (hitbox && opponent.health > 0 && !this.attackHit) {
            const oppRect = { x: opponent.x + 10, y: opponent.y, w: opponent.width - 20, h: opponent.height };
            if (this.rectOverlap(hitbox, oppRect)) {
              let dmg = this.attackType === 'kick' ? 12 : 8;
              if (this.strengthBoost > 0) dmg *= 2;
              opponent.health = Math.max(0, opponent.health - dmg);
              // compute hit position (center of hitbox)
              const hx = hitbox.x + hitbox.w / 2;
              const hy = hitbox.y + hitbox.h / 2;
              opponent.registerHit && opponent.registerHit(hx, hy, dmg);
              this.attackHit = true;
            }
          }
        } else if (!this.isAI) {
          this.vx *= 0.85;
          const moveSpeed = this.speedBoost > 0 ? 8 : 4;
          if (keys[this.keys.left]) { this.vx = -moveSpeed; this.facing = -1; }
          if (keys[this.keys.right]) { this.vx = moveSpeed; this.facing = 1; }
          const jumpPower = this.jumpBoost > 0 ? -28 : -16;
          if (keys[this.keys.jump] && this.onPlatform) this.vy = jumpPower;
        } else {
          this.vx *= 0.9;
        }

        this.vy += GRAVITY;
        this.x += this.vx;
        this.y += this.vy;

        // Platform collision
        this.onPlatform = false;
        if (this.vy >= 0) {
          for (const plat of platforms) {
            if (this.x + this.width > plat.x && this.x < plat.x + plat.w &&
                this.y + this.height >= plat.y - 5 && this.y + this.height <= plat.y + 20) {
              this.y = plat.y - this.height;
              this.vy = 0;
              this.onPlatform = true;
              break;
            }
          }
        }

        if (this.y >= GROUND_Y) { this.y = GROUND_Y; this.vy = 0; this.onPlatform = true; }
        this.x = Math.max(20, Math.min(canvas.width - this.width - 20, this.x));

        // Always face opponent
        this.facing = opponent.x + opponent.width/2 < this.x + this.width/2 ? -1 : 1;

        // Update powerup timers
        if (this.strengthBoost > 0) this.strengthBoost--;
        if (this.speedBoost > 0) this.speedBoost--;
        if (this.jumpBoost > 0) this.jumpBoost--;
        if (this.opacityBoost > 0) this.opacityBoost--;

        this.animFrame++;
      }

      attack(type) {
        if (this.isAttacking || this.attackCooldown > 0) return;
        this.isAttacking = true;
        this.attackType = type;
        this.attackHit = false;
        this.attackTimer = type === 'kick' ? 14 : 12;
      }

      rectOverlap(a, b) {
        return a.x < b.x + b.w && a.x + a.w > b.x && a.y < b.y + b.h && a.y + a.h > b.y;
      }

      registerHit(hitX, hitY, damage) {
        this.hitTimer = 18;
        this.lastHitX = hitX;
        this.lastHitY = hitY;
        spawnBlood(hitX, hitY, '#b91c1c');
      }

      // Draw proper pixel art fighter (16x14 pixel grid, scale 2.5)
      draw() {
        ctx.save();
        ctx.imageSmoothingEnabled = true;
        // idle bobbing
        const bob = Math.sin(this.animFrame / 12) * 2;
        ctx.translate(this.x + this.width / 2, this.y + this.height / 2 + bob);
        if (this.facing === -1) ctx.scale(-1, 1);
        ctx.translate(-this.width / 2, -this.height / 2);

        const s = 3.75; // pixel scale - 16x20 sprite
        const p = (x, y, w, h, col) => { ctx.fillStyle = col; ctx.fillRect(x * s, y * s, (w||1) * s, (h||1) * s); };

        // Pixel art fighter sprite (16x20 grid - classic retro style)
        // Head - skin (connected neck)
        p(6,0,4,1,'#ffdbac'); p(5,1,6,2,'#ffdbac'); p(5,3,6,1,'#ffdbac');
        // neck
        p(7,4,2,1,'#ffdbac');
        // Hair
        p(4,0,4,1,'#2d1b0e'); p(3,1,1,2,'#2d1b0e'); p(8,1,1,2,'#2d1b0e');
        // Eyes
        p(5,2,1,1,'#000'); p(8,2,1,1,'#000');
        // Body - shirt (connected torso)
        p(3,5,10,5,this.color);
        // Belt
        p(4,10,4,1,'#d4a84b');
        // Pants/legs with walking animation
        const isWalking = Math.abs(this.vx) > 0.5;
        let legOffset = 0;
        if (isWalking) {
          // Walking animation: legs swing back and forth
          legOffset = Math.sin(this.animFrame / 8) * 2;
        }
        p(4,11 + legOffset,2,5,'#2d4059'); p(8,11 - legOffset,2,5,'#2d4059'); p(3,16,2,2,'#1a2634'); p(9,16,2,2,'#1a2634');
        // Arms / Attack animations
        const drawNeutralArms = () => { p(10,4,2,3,this.color); p(2,4,2,3,this.color); };
        if (this.isAttacking && this.attackType) {
          const dur = this.attackType === 'kick' ? 14 : 12;
          const prog = 1 - Math.max(0, this.attackTimer) / dur; // 0 -> 1 over attack

          if (this.attackType === 'punch') {
            // Punch: extend right arm forward and add visible hand
            const extend = Math.round(prog * 6); // how far arm reaches
            const armW = 2 + extend;
            p(10,4,armW,2,this.color);
            // small forearm/hand
            p(10 + armW,5,1,1,this.color);
            p(10 + armW,4,1,2,'#ffdbac');
            // keep left arm visible
            p(2,4,2,3,this.color);
          } else if (this.attackType === 'kick') {
            // Kick: swing lower limb forward (down-right) and add foot
            const swing = Math.round(prog * 5);
            p(10,4,2,3,this.color); // right upper arm static
            p(2,4,2,3,this.color);  // left arm static
            // upper leg
            p(4,10,2,5,'#2d4059'); p(8,10,2,5,'#2d4059');
            // dynamic kicking leg overlay (extends outward)
            p(8 + swing,12,3,2,this.color);
            p(12 + swing,13,4,1,this.color);
            p(15 + swing,12,2,2,'#2d4059');
          } else {
            drawNeutralArms();
          }
        } else {
          drawNeutralArms();
        }
        // Shoes
        p(3,17,2,2,'#1a1a2e'); p(9,17,2,2,'#1a1a2e');

        // Opacity powerup effect
        if (this.opacityBoost > 0) {
          ctx.globalAlpha = 0.5;
        }

        ctx.globalAlpha = 1;
        ctx.restore();
      }
    }

    // Game state
    let p1, p2, keys = {}, gameRunning = false, singlePlayer = false;
    let p1RoundWins = 0, p2RoundWins = 0, currentRound = 1;
    let roundTimer = ROUND_TIME, lastTime = 0, roundPaused = false, roundEnding = false;
    // Camera system to follow players
    let cameraY = 0;

    const keyMap = {
      p1: { left: 'KeyA', right: 'KeyD', jump: 'KeyW', punch: 'KeyG', kick: 'KeyH' },
      p2: { left: 'ArrowLeft', right: 'ArrowRight', jump: 'ArrowUp', punch: 'KeyK', kick: 'KeyL' }
    };

    function initGame(vsAI = false) {
      singlePlayer = vsAI;
      // Update keyMap based on game mode
      if (singlePlayer) {
        // Single player: arrow keys for movement, A for punch, D for kick
        keyMap.p1 = { left: 'ArrowLeft', right: 'ArrowRight', jump: 'ArrowUp', punch: 'KeyA', kick: 'KeyD' };
      } else {
        // Two player: WASD for P1, arrow keys for P2
        keyMap.p1 = { left: 'KeyA', right: 'KeyD', jump: 'KeyW', punch: 'KeyG', kick: 'KeyH' };
      }
      p1RoundWins = 0;
      p2RoundWins = 0;
      currentRound = 1;
      roundTimer = ROUND_TIME;
      roundPaused = false;
      roundEnding = false;
      startRound();
    }

    function startRound() {
      p1 = new Fighter(100, window.playerColor || '#e94560', keyMap.p1, 1, false);
      p2 = new Fighter(canvas.width - 160, window.player2Color || '#7c3aed', keyMap.p2, -1, singlePlayer);
      roundTimer = ROUND_TIME;
      powerups.length = 0;
      powerupSpawnTimer = POWERUP_SPAWN_INTERVAL - 120;
      lastTime = performance.now();
      document.getElementById('roundScreen').style.display = 'flex';
      document.getElementById('roundTitle').textContent = 'ROUND ' + currentRound;
      document.getElementById('roundSubtitle').textContent = 'First to 3 wins • 60 sec per round';
      setTimeout(() => {
        document.getElementById('roundScreen').style.display = 'none';
      }, 2000);
    }

    function drawBackground() {
      // Night sky gradient
      const g = ctx.createLinearGradient(0, 0, 0, canvas.height);
      g.addColorStop(0, '#0c1445');
      g.addColorStop(0.3, '#1a237e');
      g.addColorStop(0.6, '#283593');
      g.addColorStop(1, '#1a1a2e');
      ctx.fillStyle = g;
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      // Stars
      ctx.fillStyle = 'rgba(255,255,255,0.8)';
      for (let i = 0; i < 40; i++) {
        const sx = (i * 47) % canvas.width;
        const sy = (i * 31) % 120;
        ctx.fillRect(sx, sy, 2, 2);
      }

      // City skyline - back buildings (dark)
      ctx.fillStyle = '#0d1b2a';
      const backBuildings = [
        [0, 300, 120, 240], [135, 270, 90, 270], [240, 330, 150, 210], [405, 240, 105, 300],
        [525, 285, 135, 255], [675, 315, 120, 225], [810, 255, 150, 285], [975, 300, 120, 240]
      ];
      backBuildings.forEach(([x, y, w, h]) => ctx.fillRect(x, y, w, h));

      // Building windows (lit) - deterministic pattern
      ctx.fillStyle = '#ffeb3b';
      const windowGrids = [[30,330],[82,345],[165,308],[292,368],[442,293],[562,323],[720,353],[847,308]];
      windowGrids.forEach(([bx, by], bi) => {
        for (let r = 0; r < 4; r++) {
          for (let c = 0; c < 3; c++) {
            if ((bi + r * 3 + c) % 3 !== 0) ctx.fillRect(bx + c * 12, by + r * 15, 8, 10);
          }
        }
      });

      // Mid buildings
      ctx.fillStyle = '#1b263b';
      ctx.fillRect(0, 375, 180, 165); ctx.fillRect(195, 390, 150, 150);
      ctx.fillRect(360, 383, 210, 158); ctx.fillRect(585, 398, 165, 143);
      ctx.fillRect(765, 387, 195, 153);

      // Street/ground
      ctx.fillStyle = '#2d3748';
      ctx.fillRect(0, GROUND_Y, canvas.width, canvas.height - GROUND_Y);
      ctx.fillStyle = '#4a5568';
      for (let i = 0; i < canvas.width; i += 24) {
        ctx.fillRect(i, GROUND_Y, 12, 6);
      }
    }

    function drawHealthBars() {
      const barW = 200;
      const barH = 16;
      const pad = 20;
      const p1Label = singlePlayer ? 'YOU' : 'P1';
      const p2Label = singlePlayer ? 'CPU' : 'P2';

      ctx.font = '8px "Press Start 2P"';
      ctx.fillStyle = '#fff';
      ctx.strokeStyle = '#fff';
      ctx.lineWidth = 2;

      // P1 / YOU
      ctx.fillStyle = '#333';
      ctx.fillRect(pad, pad, barW, barH);
      ctx.fillStyle = '#e94560';
      ctx.fillRect(pad, pad, (p1.health / 100) * barW, barH);
      ctx.strokeRect(pad, pad, barW, barH);
      ctx.fillText(p1Label, pad, pad - 4);

      // P2 / CPU
      ctx.fillStyle = '#333';
      ctx.fillRect(canvas.width - pad - barW, pad, barW, barH);
      ctx.fillStyle = singlePlayer ? '#7c3aed' : '#4ade80';
      ctx.fillRect(canvas.width - pad - barW + (1 - p2.health / 100) * barW, pad, (p2.health / 100) * barW, barH);
      ctx.strokeRect(canvas.width - pad - barW, pad, barW, barH);
      ctx.fillText(p2Label, canvas.width - pad - barW, pad - 4);

      // Round score
      ctx.fillStyle = '#fff';
      ctx.fillText(p1RoundWins + ' - ' + p2RoundWins, canvas.width / 2 - 30, pad - 4);

      // Timer
      ctx.fillStyle = roundTimer <= 10 ? '#e94560' : '#fff';
      ctx.font = '12px "Press Start 2P"';
      const mins = Math.floor(roundTimer / 60);
      const secs = Math.floor(roundTimer % 60);
      ctx.fillText(String(mins).padStart(2,'0') + ':' + String(secs).padStart(2,'0'), canvas.width / 2 - 28, 55);
    }

    function endRound(winner) {
      if (winner === 1) p1RoundWins++;
      else if (winner === 2) p2RoundWins++;
      const winsNeeded = 3;
      const roundsDone = currentRound >= TOTAL_ROUNDS;
      const matchOver = p1RoundWins >= winsNeeded || p2RoundWins >= winsNeeded || roundsDone;

      if (matchOver) {
        gameRunning = false;
        gameOverScreen.style.display = 'flex';
        const p1Wins = p1RoundWins > p2RoundWins;
        const tie = p1RoundWins === p2RoundWins;
        if (tie) {
          winnerText.textContent = 'DRAW!';
        } else if (singlePlayer) {
          winnerText.textContent = p1Wins ? 'YOU WIN!' : 'YOU LOSE!';
        } else {
          winnerText.textContent = p1Wins ? 'PLAYER 1 WINS!' : 'PLAYER 2 WINS!';
        }
        document.getElementById('roundScoreText').textContent = 'Final: ' + p1RoundWins + ' - ' + p2RoundWins;
      } else {
        // Only increment round if it wasn't a tie
        if (winner !== 0) {
          currentRound++;
        }
        document.getElementById('roundScreen').style.display = 'flex';
        const rText = winner === 1 ? (singlePlayer ? 'YOU WIN ROUND!' : 'P1 WINS ROUND!') : (winner === 2 ? (singlePlayer ? 'CPU WINS ROUND!' : 'P2 WINS ROUND!') : 'TIE!');
        document.getElementById('roundTitle').textContent = rText;
        document.getElementById('roundSubtitle').textContent = 'Score: ' + p1RoundWins + ' - ' + p2RoundWins + ' • Next round...';
        setTimeout(() => {
          document.getElementById('roundScreen').style.display = 'none';
          roundEnding = false;
          startRound();
        }, 2000);
      }
    }

    function updateCamera() {
      // Camera follows the average Y position of both players, keeping them centered vertically
      const avgY = (p1.y + p2.y) / 2;
      const targetCameraY = avgY - canvas.height / 3;
      // Clamp camera to valid bounds
      cameraY = Math.max(0, Math.min(targetCameraY, 720 - canvas.height));
    }

    function gameLoop() {
      if (!gameRunning) return;
      if (roundPaused) return;

      const now = performance.now();
      roundTimer -= (now - lastTime) / 1000;
      lastTime = now;
      if (roundTimer < 0) roundTimer = 0;

      ctx.clearRect(0, 0, canvas.width, canvas.height);
      
      // Update camera to follow players
      updateCamera();
      // Apply camera translation
      ctx.save();
      ctx.translate(0, -cameraY);
      
      drawBackground();
      drawPlatforms();

      if (keys[keyMap.p1.punch]) p1.attack('punch');
      if (keys[keyMap.p1.kick]) p1.attack('kick');
      if (!p2.isAI && keys[keyMap.p2.punch]) p2.attack('punch');
      if (!p2.isAI && keys[keyMap.p2.kick]) p2.attack('kick');

      p1.update(p2);
      p2.update(p1);

      // Check powerup collision
      checkPowerupCollision(p1);
      checkPowerupCollision(p2);

      p1.draw();
      p2.draw();

      // update and draw effects and powerups
      updateEffects();
      updatePowerups();
      drawEffects();
      drawPowerups();

      // Restore context to draw UI on top (without camera offset)
      ctx.restore();
      
      // Draw HUD (health bars, timer, score) on screen
      drawHealthBars();

      if (roundEnding) return;

      if (p1.health <= 0 || p2.health <= 0) {
        roundEnding = true;
        const winner = p1.health <= 0 ? 2 : 1;
        endRound(winner);
        return;
      }
      if (roundTimer <= 0) {
        roundEnding = true;
        const winner = p1.health > p2.health ? 1 : (p2.health > p1.health ? 2 : 0);
        endRound(winner);
      }
    }

    document.addEventListener('keydown', e => {
      keys[e.code] = true;
      if (['KeyW', 'KeyA', 'KeyS', 'KeyD', 'ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', 'Space'].includes(e.code)) {
        e.preventDefault();
      }
    });
    document.addEventListener('keyup', e => { keys[e.code] = false; });

    document.getElementById('vsAiBtn').addEventListener('click', () => {
      // show color selection modal for single-player
      window.pendingMode = 'single';
      colorDropdown.value = window.playerColor || '#e94560';
      colorDropdownP2.value = window.player2Color || '#7c3aed';
      startScreen.style.display = 'none';
      colorSelect.style.display = 'flex';
    });

    document.getElementById('vsPlayerBtn').addEventListener('click', () => {
      // show color selection modal for two-player mode
      window.pendingMode = 'duo';
      colorDropdown.value = window.playerColor || '#e94560';
      colorDropdownP2.value = window.player2Color || '#7c3aed';
      startScreen.style.display = 'none';
      colorSelect.style.display = 'flex';
    });

    document.getElementById('playAgainBtn').addEventListener('click', () => {
      gameOverScreen.style.display = 'none';
      initGame(singlePlayer);
      gameRunning = true;
    });

    document.getElementById('menuBtnOver').addEventListener('click', () => {
      gameRunning = false;
      gameOverScreen.style.display = 'none';
      document.getElementById('menuBtn').style.display = 'none';
      startScreen.style.display = 'flex';
    });

    document.getElementById('menuBtn').addEventListener('click', () => {
      roundPaused = true;
      document.getElementById('pauseMenu').style.display = 'flex';
    });

    document.getElementById('resumeBtn').addEventListener('click', () => {
      roundPaused = false;
      lastTime = performance.now();
      document.getElementById('pauseMenu').style.display = 'none';
    });

    document.getElementById('quitToMenuBtn').addEventListener('click', () => {
      gameRunning = false;
      roundPaused = false;
      document.getElementById('pauseMenu').style.display = 'none';
      document.getElementById('menuBtn').style.display = 'none';
      document.getElementById('gameOverScreen').style.display = 'none';
      startScreen.style.display = 'flex';
    });

    setInterval(gameLoop, 1000 / 60);
  </script>
</body>
</html>
